<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Create a rotating globe</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js"></script>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://use.typekit.net/ebm6rjj.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap"
        rel="stylesheet">


    <style>
        #map {
            opacity: 60%;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <div class="vertical">
        <h1>
            Land Grabbing
            <br>
            <b>Ein abgekartetes Spiel</b>
        </h1>
        <div class="horizontal">
            <a href="/informationsgestaltung/flat.html" class="container">
                <h2>Verbindungskarte</h2>
                <p>-> Sieh dir auf der Verbindungskarte an, welche Länder wo Land gekauft haben.</p>
            </a>
            <a href="/informationsgestaltung/globe.html" class="container">
                <h2>Globus-Ansicht</h2>
                <p>-> Sieh dir auf dem Globus das Ausmaß von internationalen.</p>
            </a>

        </div>
    </div>
    <div> </div>


    <script>
        mapboxgl.accessToken = 'pk.eyJ1IjoicmFwaGFlbC16aWVtb3dza2ktaGZnIiwiYSI6ImNsdjB3empvNTAwcGcyam1pMTloc2wzcXMifQ.DKC-hNqOY3tw4HhkJEvtsA';
        const map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/raphael-ziemowski-hfg/clvhaybc0018h01ph0psx9jx4',
            projection: 'globe', // Display the map as a globe, since satellite-v9 defaults to Mercator
            zoom: 2.5,
            center: [-90, 40],
            interactive: false,
        });
        const definedCountry = ''; // Ändere das Land hier





        function filterData(data, country) {
            if (!country) return data;

            return {
                ...data,
                features: data.features.filter(feature => {
                    const targetCountry = feature.properties['Target country'] || feature.properties['countryName'];
                    const operatingCountry = feature.properties['Operating company: Country of registration/origin'];
                    return targetCountry === country || operatingCountry === country;
                })
            };
        }

        function getCountryBounds(data, country) {
            const countryFeature = data.features.find(feature => feature.properties['countryName'] === country);
            if (!countryFeature) return null;

            const coordinates = countryFeature.geometry.coordinates;
            if (countryFeature.geometry.type === 'Point') {
                return new mapboxgl.LngLatBounds(coordinates, coordinates);
            } else if (countryFeature.geometry.type === 'Polygon') {
                const bounds = new mapboxgl.LngLatBounds(coordinates[0][0], coordinates[0][0]);
                coordinates[0].forEach(coord => {
                    bounds.extend(coord);
                });
                return bounds;
            } else if (countryFeature.geometry.type === 'MultiPolygon') {
                const bounds = new mapboxgl.LngLatBounds(coordinates[0][0][0], coordinates[0][0][0]);
                coordinates.forEach(polygon => {
                    polygon[0].forEach(coord => {
                        bounds.extend(coord);
                    });
                });
                return bounds;
            }
            return null;
        }

        function updateSidebar(countryData) {
            const countryFeature = countryData.features[0]; // Annahme: Nur das erste Feature wird verwendet

            if (countryFeature) {
                const properties = countryFeature.properties;
                document.getElementById('areaSoldLabel').textContent = properties['areaSold'] || '-';
                document.getElementById('areaBoughtLabel').textContent = properties['areaBought'] || '-';
                document.getElementById('numberSoldLabel').textContent = properties['numberSold'] || '-';
                document.getElementById('numberBoughtLabel').textContent = properties['numberBought'] || '-';
                document.getElementById('mostDealsWithLabel').textContent = properties['mostDealsWith'] || '-';
            } else {
                // Setze Standardwerte oder leere die Sidebar
                document.getElementById('areaSoldLabel').textContent = '-';
                document.getElementById('areaBoughtLabel').textContent = '-';
                document.getElementById('numberSoldLabel').textContent = '-';
                document.getElementById('numberBoughtLabel').textContent = '-';
                document.getElementById('mostDealsWithLabel').textContent = '-';
            }
            console.log('Country Feature:', countryFeature);
            console.log('Properties:', properties);

        }


        map.on('load', function () {
            fetch('Dataset-Connections.json')
                .then(response => response.json())
                .then(lineData => {
                    const filteredLineData = filterData(lineData, definedCountry);

                    map.addSource('line-data', {
                        'type': 'geojson',
                        'data': filteredLineData,
                        'lineMetrics': true
                    });

                    map.addLayer({
                        'id': 'line-layer',
                        'type': 'line',
                        'source': 'line-data',
                        'layout': {
                            'line-join': 'round',
                            'line-cap': 'round'
                        },
                        'paint': {
                            'line-width': [
                                'interpolate',
                                ['linear'],
                                ['get', 'Deal size'],
                                0, 0,
                                32000000, 25,
                            ],
                            'line-gradient': [
                                'interpolate',
                                ['linear'],
                                ['line-progress'],
                                0, "rgba(235,16,100, 0.2)",
                                0.4, "rgba(235,16,100, 0.2)",
                                0.6, "rgba(80, 159, 57, 0.2)",
                                1, "rgba(80, 159, 57, 0.2)"
                            ],
                            'line-opacity': 1,
                        }
                    });

                    fetch('Dataset-Countries-missing-data.geojson')
                        .then(response => response.json())
                        .then(countryData => {
                            const filteredCountryData = filterData(countryData, definedCountry);

                            map.addSource('country-data', {
                                'type': 'geojson',
                                'data': filteredCountryData
                            });

                            map.addLayer({
                                'id': 'target-circles',
                                'type': 'heatmap',
                                'source': 'country-data',
                                'paint': {
                                    'heatmap-radius': [
                                        'interpolate',
                                        ['linear'],
                                        ['get', 'areaSold'],
                                        0, 0,
                                        32000000, 25,
                                    ],
                                    'heatmap-color': [
                                        'interpolate',
                                        ['linear'],
                                        ['heatmap-density'],
                                        0, 'rgba(235,16,100,0)',
                                        0.05, 'rgb(235,16,100)'
                                    ],
                                }
                            });

                            map.addLayer({
                                'id': 'origin-circles',
                                'type': 'heatmap',
                                'source': 'country-data',
                                'paint': {
                                    'heatmap-radius': [
                                        'interpolate',
                                        ['linear'],
                                        ['get', 'areaBought'],
                                        0, 0,
                                        32000000, 25,
                                    ],
                                    'heatmap-color': [
                                        'interpolate',
                                        ['linear'],
                                        ['heatmap-density'],
                                        0, 'rgba(80, 159, 57,0)',
                                        0.05, 'rgb(80, 159, 57)'
                                    ],
                                }
                            });



                            map.on('click', function (e) {
                                const features = map.queryRenderedFeatures(e.point, {
                                    layers: ['target-circles', 'origin-circles'] // Layer-Name für das Klicken
                                });

                                if (!features.length) {
                                    return;
                                }

                                const clickedFeature = features[0];
                                const countryName = clickedFeature.properties['countryName'];

                                updateSidebar(filteredCountryData); // Sidebar aktualisieren
                            });

                        })
                        .catch(error => console.error('Error loading Country JSON data:', error));
                })
                .catch(error => console.error('Error loading Line JSON data:', error));
        });

        // The following values can be changed to control rotation speed:

        // At low zooms, complete a revolution every two minutes.
        const secondsPerRevolution = 120;
        // Above zoom level 5, do not rotate.
        const maxSpinZoom = 5;
        // Rotate at intermediate speeds between zoom levels 3 and 5.
        const slowSpinZoom = 3;

        let userInteracting = false;
        let spinEnabled = true;

        function spinGlobe() {
            const zoom = map.getZoom();
            if (spinEnabled && !userInteracting && zoom < maxSpinZoom) {
                let distancePerSecond = 360 / secondsPerRevolution;
                if (zoom > slowSpinZoom) {
                    // Slow spinning at higher zooms
                    const zoomDif =
                        (maxSpinZoom - zoom) / (maxSpinZoom - slowSpinZoom);
                    distancePerSecond *= zoomDif;
                }
                const center = map.getCenter();
                center.lng -= distancePerSecond;
                // Smoothly animate the map over one second.
                // When this animation is complete, it calls a 'moveend' event.
                map.easeTo({ center, duration: 1000, easing: (n) => n });
            }
        }

        // Pause spinning on interaction
        map.on('mousedown', () => {
            userInteracting = true;
        });

        // Restart spinning the globe when interaction is complete
        map.on('mouseup', () => {
            userInteracting = false;
            spinGlobe();
        });

        // These events account for cases where the mouse has moved
        // off the map, so 'mouseup' will not be fired.
        map.on('dragend', () => {
            userInteracting = false;
            spinGlobe();
        });
        map.on('pitchend', () => {
            userInteracting = false;
            spinGlobe();
        });
        map.on('rotateend', () => {
            userInteracting = false;
            spinGlobe();
        });

        // When animation is complete, start spinning if there is no ongoing interaction
        map.on('moveend', () => {
            spinGlobe();
        });


        spinGlobe();
    </script>

</body>

</html>
